/*
 * HeliumBoot/EFI - A simple UEFI bootloader.
 *
 * Copyright (c) 2025 Stefanos Stefanidis.
 * All rights reserved.
 *
 * This file is part of HeliumBoot/EFI.
 *
 * HeliumBoot/EFI is free software: you can redistribute it and/or modify it under the terms of the GNU General
 * Public License as published by the Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * HeliumBoot/EFI is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
 * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with HeliumBoot/EFI. If not, see
 * <https://www.gnu.org/licenses/>.
 */

/*
 * Portions of this code are derived from Symbian's ubootldr, adapted for UEFI,
 * which can be found here: https://github.com/cdaffara/symbiandump-os1/tree/master/sf/os/kernelhwsrv/brdbootldr/ubootldr
 *
 * These portions of code are licensed under the Eclipse Public License v1.0.
 * It is available at the URL "http://www.eclipse.org/legal/epl-v10.html".
 *
 * Copyright (c) 1996-2009 Nokia Corporation and/or its subsidiary(-ies).
 * All rights reserved.
 *
 * In addition, some code is derived from GNU-EFI, adapted for this
 * graphics renderer. Specifically, the functions "InputToScreen()" and
 * "InputToScreen_Internal()".
 *
 * Copyright (c) 1998-2000 Intel Corporation
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted
 * provided that the following conditions are met:
 *
 * Redistributions of source code must retain the above copyright notice, this list of conditions and
 * the following disclaimer.
 *
 * Redistributions in binary form must reproduce the above copyright notice, this list of conditions
 * and the following disclaimer in the documentation and/or other materials provided with the
 * distribution.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE. THE EFI SPECIFICATION AND ALL OTHER INFORMATION
 * ON THIS WEB SITE ARE PROVIDED "AS IS" WITH NO WARRANTIES, AND ARE SUBJECT
 * TO CHANGE WITHOUT NOTICE.
 */

#include <efi.h>
#include <efilib.h>

#include <stdarg.h>

#include "boot.h"

UINT8 *Screen;
UINTN Screenwidth;
UINTN Screenheight;
UINTN PixelsPerScanLine;
UINTN PixelSize = 4;
INTN XPos;
INTN YPos;
UINTN Colours;

UINTN Progress[2];
UINTN Pixels[2];
UINTN Limit[2];
UINT32 ProgressTime[2];
UINT32 StartTime;

BOOLEAN VideoInitFlag = FALSE;

const UINTN KRgbBlack		= 0x000000;
const UINTN KRgbDarkGray	= 0x555555;
const UINTN KRgbDarkRed		= 0x800000;
const UINTN KRgbDarkGreen	= 0x008000;
const UINTN KRgbDarkYellow	= 0x808000;
const UINTN KRgbDarkBlue	= 0x000080;
const UINTN KRgbDarkMagenta	= 0x800080;
const UINTN KRgbDarkCyan	= 0x008080;
const UINTN KRgbRed			= 0xFF0000;
const UINTN KRgbGreen		= 0x00FF00;
const UINTN KRgbYellow		= 0xFFFF00;
const UINTN KRgbBlue		= 0x0000FF;
const UINTN KRgbMagenta		= 0xFF00FF;
const UINTN KRgbCyan		= 0x00FFFF;
const UINTN KRgbGray		= 0xAAAAAA;
const UINTN KRgbWhite		= 0xFFFFFF;
const UINTN KRgbDimWhite    = 0xCCCCCC;

const UINT32 Palette32[16] = {
    KRgbBlack,       // 0
    KRgbDarkBlue,    // 1
    KRgbDarkGreen,   // 2
    KRgbDarkCyan,    // 3
    KRgbDarkRed,     // 4
    KRgbDarkMagenta, // 5
    KRgbDarkYellow,  // 6
    KRgbDimWhite,    // 7
    KRgbGray,        // 8
    KRgbBlue,        // 9
    KRgbDarkGreen,   // 10
    KRgbCyan,        // 11
    KRgbRed,         // 12
    KRgbMagenta,     // 13
    KRgbYellow,      // 14
    KRgbWhite        // 15
};

const UINT8 KForeground = 15;
const UINT8 KBackground = 9;
const UINTN PColour[2]= { 0xa08, 0xc08 };
const UINTN IPColour[2]= { 0x809, 0x809 };

#define NUM_FONTS	96
#define FONT_HEIGHT	10
#define FONT_WIDTH	8

#define SCREEN_SIZE		(Screenheight * Screenwidth * PixelSize)	// number of pixels (size in bytes)
#define MAX_COLUMN		(Screenwidth/FONT_WIDTH)	// chars per line e.g. 80 or 40
#define MAX_ROW		(Screenheight/FONT_HEIGHT)	// lines per screen e.g. 48 or 24
#define PROGRESSBAR0_ROW (MAX_ROW-1)	// row in which to draw progress bar 0
#define PROGRESSBAR1_ROW (MAX_ROW-2)	// row in which to draw progress bar 1
#define STATS_ROW (MAX_ROW-3)	// DEBUGGING row in which to write eta/bps

static const UINT8 Font[NUM_FONTS][FONT_HEIGHT] = {
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x30,0x78,0x78,0x78,0x30,0x00,0x30,0x00,0x00,0x00},	// !
	{0x6C,0x6C,0x6C,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x6C,0x6C,0xFE,0x6C,0xFE,0x6C,0x6C,0x00,0x00,0x00},	// #
	{0x30,0x7C,0xC0,0x78,0x0C,0xF8,0x30,0x00,0x00,0x00},	// $
	{0x00,0xC6,0xCC,0x18,0x30,0x66,0xC6,0x00,0x00,0x00},
	{0x38,0x6C,0x38,0x76,0xDC,0xCC,0x76,0x00,0x00,0x00},
	{0x60,0x60,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x18,0x30,0x60,0x60,0x60,0x30,0x18,0x00,0x00,0x00},
	{0x60,0x30,0x18,0x18,0x18,0x30,0x60,0x00,0x00,0x00},
	{0x00,0x66,0x3C,0xFF,0x3C,0x66,0x00,0x00,0x00,0x00},
	{0x00,0x30,0x30,0xFC,0x30,0x30,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x30,0x30,0x60,0x00,0x00},
	{0x00,0x00,0x00,0xFC,0x00,0x00,0x00,0x00,0x00,0x00},	// -
	{0x00,0x00,0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x00},	// .
	{0x06,0x0C,0x18,0x30,0x60,0xC0,0x80,0x00,0x00,0x00},	// /

	{0x7C,0xC6,0xCE,0xDE,0xF6,0xE6,0x7C,0x00,0x00,0x00},	// 0
	{0x30,0x70,0x30,0x30,0x30,0x30,0xFC,0x00,0x00,0x00},	// 1
	{0x78,0xCC,0x0C,0x38,0x60,0xCC,0xFC,0x00,0x00,0x00},	// 2
	{0x78,0xCC,0x0C,0x38,0x0C,0xCC,0x78,0x00,0x00,0x00},	// 3
	{0x1C,0x3C,0x6C,0xCC,0xFE,0x0C,0x1E,0x00,0x00,0x00},	// 4
	{0xFC,0xC0,0xF8,0x0C,0x0C,0xCC,0x78,0x00,0x00,0x00},	// 5
	{0x38,0x60,0xC0,0xF8,0xCC,0xCC,0x78,0x00,0x00,0x00},	// 6
	{0xFC,0xCC,0x0C,0x18,0x30,0x30,0x30,0x00,0x00,0x00},	// 7
	{0x78,0xCC,0xCC,0x78,0xCC,0xCC,0x78,0x00,0x00,0x00},	// 8
	{0x78,0xCC,0xCC,0x7C,0x0C,0x18,0x70,0x00,0x00,0x00},	// 9
	{0x00,0x30,0x30,0x00,0x00,0x30,0x30,0x00,0x00,0x00},	// :
	{0x00,0x30,0x30,0x00,0x00,0x30,0x30,0x60,0x00,0x00},	// ;
	{0x18,0x30,0x60,0xC0,0x60,0x30,0x18,0x00,0x00,0x00},	// <
	{0x00,0x00,0xFC,0x00,0x00,0xFC,0x00,0x00,0x00,0x00},	// =
	{0x60,0x30,0x18,0x0C,0x18,0x30,0x60,0x00,0x00,0x00},	// >
	{0x78,0xCC,0x0C,0x18,0x30,0x00,0x30,0x00,0x00,0x00},	// ?

	{0x7C,0xC6,0xDE,0xDE,0xDE,0xC0,0x78,0x00,0x00,0x00},	// @
	{0x30,0x78,0xCC,0xCC,0xFC,0xCC,0xCC,0x00,0x00,0x00},	// A
	{0xFC,0x66,0x66,0x7C,0x66,0x66,0xFC,0x00,0x00,0x00},	// B
	{0x3C,0x66,0xC0,0xC0,0xC0,0x66,0x3C,0x00,0x00,0x00},	// C
	{0xF8,0x6C,0x66,0x66,0x66,0x6C,0xF8,0x00,0x00,0x00},	// D
	{0x7E,0x60,0x60,0x78,0x60,0x60,0x7E,0x00,0x00,0x00},	// E
	{0x7E,0x60,0x60,0x78,0x60,0x60,0x60,0x00,0x00,0x00},	// F
	{0x3C,0x66,0xC0,0xC0,0xCE,0x66,0x3E,0x00,0x00,0x00},	// G
	{0xCC,0xCC,0xCC,0xFC,0xCC,0xCC,0xCC,0x00,0x00,0x00},	// H
	{0x78,0x30,0x30,0x30,0x30,0x30,0x78,0x00,0x00,0x00},	// I
	{0x1E,0x0C,0x0C,0x0C,0xCC,0xCC,0x78,0x00,0x00,0x00},	// J
	{0xE6,0x66,0x6C,0x78,0x6C,0x66,0xE6,0x00,0x00,0x00},	// K
	{0x60,0x60,0x60,0x60,0x60,0x60,0x7E,0x00,0x00,0x00},	// L
	{0xC6,0xEE,0xFE,0xFE,0xD6,0xC6,0xC6,0x00,0x00,0x00},	// M
	{0xC6,0xE6,0xF6,0xDE,0xCE,0xC6,0xC6,0x00,0x00,0x00},	// N
	{0x38,0x6C,0xC6,0xC6,0xC6,0x6C,0x38,0x00,0x00,0x00},	// O

	{0xFC,0x66,0x66,0x7C,0x60,0x60,0xF0,0x00,0x00,0x00},	// P
	{0x78,0xCC,0xCC,0xCC,0xDC,0x78,0x1C,0x00,0x00,0x00},	// Q
	{0xFC,0x66,0x66,0x7C,0x6C,0x66,0xE6,0x00,0x00,0x00},	// R
	{0x78,0xCC,0xE0,0x70,0x1C,0xCC,0x78,0x00,0x00,0x00},	// S
	{0xFC,0x30,0x30,0x30,0x30,0x30,0x30,0x00,0x00,0x00},	// T
	{0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xFC,0x00,0x00,0x00},	// U
	{0xCC,0xCC,0xCC,0xCC,0xCC,0x78,0x30,0x00,0x00,0x00},	// V
	{0xC6,0xC6,0xC6,0xD6,0xFE,0xEE,0xC6,0x00,0x00,0x00},	// W
	{0xC6,0xC6,0x6C,0x38,0x38,0x6C,0xC6,0x00,0x00,0x00},	// X
	{0xCC,0xCC,0xCC,0x78,0x30,0x30,0x78,0x00,0x00,0x00},	// Y
	{0xFE,0x06,0x0C,0x18,0x30,0x60,0xFE,0x00,0x00,0x00},	// Z
	{0x78,0x60,0x60,0x60,0x60,0x60,0x78,0x00,0x00,0x00},
	{0xC0,0x60,0x30,0x18,0x0C,0x06,0x02,0x00,0x00,0x00},
	{0x78,0x18,0x18,0x18,0x18,0x18,0x78,0x00,0x00,0x00},
	{0x10,0x38,0x6C,0xC6,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00},

	{0x30,0x30,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x78,0x0C,0x7C,0xCC,0x76,0x00,0x00,0x00},
	{0xE0,0x60,0x60,0x7C,0x66,0x66,0xDC,0x00,0x00,0x00},
	{0x00,0x00,0x78,0xCC,0xC0,0xCC,0x78,0x00,0x00,0x00},
	{0x1C,0x0C,0x0C,0x7C,0xCC,0xCC,0x76,0x00,0x00,0x00},
	{0x00,0x00,0x78,0xCC,0xFC,0xC0,0x78,0x00,0x00,0x00},
	{0x38,0x6C,0x60,0xF0,0x60,0x60,0xF0,0x00,0x00,0x00},
	{0x00,0x00,0x76,0xCC,0xCC,0x7C,0x0C,0xF8,0x00,0x00},
	{0xE0,0x60,0x6C,0x76,0x66,0x66,0xE6,0x00,0x00,0x00},
	{0x30,0x00,0x70,0x30,0x30,0x30,0x78,0x00,0x00,0x00},
	{0x0C,0x00,0x0C,0x0C,0x0C,0xCC,0xCC,0x78,0x00,0x00},
	{0xE0,0x60,0x66,0x6C,0x78,0x6C,0xE6,0x00,0x00,0x00},
	{0x70,0x30,0x30,0x30,0x30,0x30,0x78,0x00,0x00,0x00},
	{0x00,0x00,0xCC,0xFE,0xFE,0xD6,0xC6,0x00,0x00,0x00},
	{0x00,0x00,0xF8,0xCC,0xCC,0xCC,0xCC,0x00,0x00,0x00},
	{0x00,0x00,0x78,0xCC,0xCC,0xCC,0x78,0x00,0x00,0x00},

	{0x00,0x00,0xDC,0x66,0x66,0x7C,0x60,0xF0,0x00,0x00},
	{0x00,0x00,0x76,0xCC,0xCC,0x7C,0x0C,0x1E,0x00,0x00},
	{0x00,0x00,0xDC,0x76,0x66,0x60,0xF0,0x00,0x00,0x00},
	{0x00,0x00,0x7C,0xC0,0x78,0x0C,0xF8,0x00,0x00,0x00},
	{0x10,0x30,0x7C,0x30,0x30,0x34,0x18,0x00,0x00,0x00},
	{0x00,0x00,0xCC,0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00},
	{0x00,0x00,0xCC,0xCC,0xCC,0x78,0x30,0x00,0x00,0x00},
	{0x00,0x00,0xC6,0xD6,0xFE,0xFE,0x6C,0x00,0x00,0x00},
	{0x00,0x00,0xC6,0x6C,0x38,0x6C,0xC6,0x00,0x00,0x00},
	{0x00,0x00,0xCC,0xCC,0xCC,0x7C,0x0C,0xF8,0x00,0x00},
	{0x00,0x00,0xFC,0x98,0x30,0x64,0xFC,0x00,0x00,0x00},
	{0x1C,0x30,0x30,0xE0,0x30,0x30,0x1C,0x00,0x00,0x00},
	{0x18,0x18,0x18,0x00,0x18,0x18,0x18,0x00,0x00,0x00},
	{0xE0,0x30,0x30,0x1C,0x30,0x30,0xE0,0x00,0x00,0x00},
	{0x76,0xDC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00},
};

static void InputToScreen_Internal(SIMPLE_INPUT_INTERFACE *ConIn,
	CHAR16 *Prompt, CHAR16 *InStr, UINTN StrLen);

static void
ColourPixel(INTN x, INTN y, UINTN Colour)
{
	UINT32 *Fb = (UINT32 *)Screen;

	Fb[y * PixelsPerScanLine + x] = Palette32[Colour];
}

void
ClearScreen(void)
{
	INTN x, y;

	for (y = 0; y < Screenheight; y++) {
		for (x = 0; x < Screenwidth; x++)
			ColourPixel(x, y, KBackground);
	}

	XPos = 0;
	YPos = 0;
	Colours = (KForeground << 8) | KBackground;
}

void
DisplayChar(UINT8 Char, UINTN x, UINTN y, UINTN Colour)
{
	UINTN line, pixel;
	UINT8 tmpChar = Char - 32;

	if (tmpChar < 0 || tmpChar >= NUM_FONTS)
		return;

	for (line = 0; line < FONT_HEIGHT; line++) {
		UINT8 tmpLine = Font[tmpChar][line];
		UINT8 tmpMask = 0x80;
		for (pixel = 0; pixel < FONT_WIDTH; pixel++) {
			ColourPixel(x * FONT_WIDTH + pixel, y * FONT_HEIGHT + line,
				(tmpLine & tmpMask) ? Colour >> 8 : Colour & 0xFF);
			tmpMask = tmpMask >> 1;
		}
	}
}

void
ScrollScreen(void)
{
	UINT8 *Fb = Screen;
	INTN x, y;

	MemMove(Fb, Fb + (Screenwidth*PixelSize * FONT_HEIGHT),
		(Screenwidth * PixelSize * (Screenheight - (2 * FONT_HEIGHT)) - (Screenwidth * PixelSize * FONT_HEIGHT)));
	Fb += (Screenwidth*PixelSize*(Screenheight-(2*FONT_HEIGHT))-(Screenwidth*PixelSize*FONT_HEIGHT));

	INTN StartLine = Screenheight - (4 * FONT_HEIGHT);
	for (y = StartLine; y < StartLine + FONT_HEIGHT; y++) {
		for (x = 0; x < Screenwidth; x++)
			ColourPixel(x, y, KBackground);
	}
}

void
ScrollScreenDown(void)
{
	INTN x, y;
	UINT8 *Fb = Screen;

	MemMove(Fb + (Screenwidth*PixelSize * FONT_HEIGHT), Fb, (Screenwidth * PixelSize * (Screenheight - (2 * FONT_HEIGHT)) - (Screenwidth * PixelSize * FONT_HEIGHT)));
	for (y = 0; y < FONT_HEIGHT; y++) {
		for (x = 0; x < Screenwidth; x++)
			ColourPixel(x, y, KBackground);
	}
}

static void
CurDown(void)
{
	if (++YPos == (MAX_ROW - 3)) {
		YPos = (MAX_ROW - 4);
		ScrollScreen();
	}
}

static void
CurUp(void)
{
	if (--YPos < 0) {
		YPos = 0;
		ScrollScreenDown();
	}
}

static void
CurRight(void)
{
	if (++XPos == MAX_COLUMN) {
		XPos = MAX_COLUMN - 1;
		CurUp();
	}
}

static void
CurLeft(void)
{
	if (--XPos < 0) {
		XPos = MAX_COLUMN - 1;
		CurUp();
	}
}

static void
SetPos(INTN X, INTN Y)
{
	XPos = X;
	YPos = Y;
}

void
PutChar(UINT8 Char)
{
	switch (Char) {
		case 8:
			CurLeft();
			return;
		case 9:
			CurRight();
			return;
		case 10:
			CurDown();
			return;
		case 11:
			CurUp();
			return;
		case 12:
			ClearScreen();
			return;
		case 13:
			XPos = 0;
			return;
		default:
			break;
	}

	DisplayChar(Char, XPos, YPos, Colours);
	if (++XPos == MAX_COLUMN) {
		XPos = 0;
		if (++YPos == (MAX_ROW - 3)) {
			YPos = (MAX_ROW - 4);
			ScrollScreen();
		}
	}
}

void
PutString(const CHAR8 *s)
{
	while (*s)
		PutChar(*s++);
}

void
PrintToScreen(const CHAR16 *Fmt, ...)
{
	INTN i;
	CHAR16 Buffer[1024];
	va_list va;

	va_start(va, Fmt);
	UnicodeVSPrint(Buffer, sizeof(Buffer), Fmt, va);
	va_end(va);

	// Convert the string to ASCII for PutChar().
	for (i = 0; Buffer[i] != L'\0'; i++) {
		CHAR16 ch = Buffer[i];
		if (ch < 0x80)
			PutChar((UINT8)ch);
		else
			PutChar('?');
	}
}

void
InputToScreen(CHAR16 *Prompt, CHAR16 *InStr, UINTN StrLen)
{
	InputToScreen_Internal(ST->ConIn, Prompt, InStr, StrLen);
}

static void
InputToScreen_Internal(SIMPLE_INPUT_INTERFACE *ConIn, CHAR16 *Prompt,
	CHAR16 *InStr, UINTN StrLen)
{
	EFI_STATUS Status;
	EFI_INPUT_KEY Key;
	UINTN Len;

	if (Prompt)
		PrintToScreen(L"%s", Prompt);

	Len = 0;

	for (;;) {
		WaitForSingleEvent(ConIn->WaitForKey, 0);

		Status = uefi_call_wrapper(ConIn->ReadKeyStroke, 2, ConIn, &Key);
		if (EFI_ERROR(Status))
			break;

		// Handle Enter keypress.
		if (Key.UnicodeChar == L'\r' || Key.UnicodeChar == L'\n')
			break;

		// Handle Backspace keypress.
		if (Key.UnicodeChar == L'\b') {
			if (Len) {
				Len--;
				InStr[Len] = L'\0';
				PutChar('\b');
				PutChar(' ');
				PutChar('\b');
			}
			continue;
		}

		if (Key.UnicodeChar >= L' ') {
			if (Len < StrLen - 1) {
				InStr[Len++] = Key.UnicodeChar;
				InStr[Len] = L'\0';

				if (Key.UnicodeChar < 0x80)
					PutChar((CHAR8)Key.UnicodeChar);
				else
					PutChar('?');
			}
		}
	}

	InStr[Len] = L'\0';
}

void
InitProgressBar(INTN Id, UINTN BarLimit, CONST CHAR8 *Buffer)
{
	CHAR8 c;
	INTN x = 0;
	INTN line = Id ? PROGRESSBAR0_ROW : PROGRESSBAR1_ROW;

	Progress[Id] = 0;
	if (Id == 0)
		StartTime = 0;

	Pixels[Id] = 0;
	Limit[Id] = BarLimit;
	while ((c = *Buffer++) != 0 && x < 7) {
		DisplayChar(c, x, line, Colours);
		++x;
	}

	if (x < 7)
		x = 7;

	for (; x < (MAX_COLUMN - 1); ++x)
		DisplayChar(0x7f, x, line, IPColour[Id]);
}

void
UpdateProgressBar(INTN Id, UINTN NewProgress)
{
	INTN i;
	INTN line = Id ? PROGRESSBAR0_ROW : PROGRESSBAR1_ROW;
	UINTN old_pixels = Pixels[Id];

	if (Id == 0) {
		UINT64 timenow;

		 if (StartTime == 0) {
			 StartTime = GetTimeSeconds();
			 ProgressTime[Id] = StartTime;
		 }

		UINT32 avg_bps = 0;
		UINT32 bps = 0;
		UINT32 eta = 0;

		timenow = GetTimeSeconds();

		UINT64 delta_time = timenow - ProgressTime[Id];
		ProgressTime[Id] = timenow;

		if (delta_time) {
			bps = ((NewProgress - Progress[Id]) * 1000) / delta_time;
			delta_time = timenow - StartTime;
			if (delta_time) {
				avg_bps = ((UINT64)NewProgress * 1000) / delta_time;
				if (avg_bps)
					eta = (Limit[Id] - NewProgress) / avg_bps;
			}
		}

		INTN savedXPos = XPos;
		INTN savedYPos = YPos;

		XPos = 0;
		YPos = STATS_ROW;

		PrintToScreen(L"point: %7u ETA: %u    ", bps, eta);

		XPos = savedXPos;
		YPos = savedYPos;
	}

	Progress[Id] = NewProgress;
	INT64 prog64 = NewProgress;
	prog64 *= (Screenwidth - (8 * FONT_WIDTH));
	prog64 /= Limit[Id];
	UINTN pixels = (UINTN)prog64;
	if (pixels > old_pixels) {
		Pixels[Id] = pixels;
		while (old_pixels < pixels) {
			for (i = 0; i < 6; ++i)
				ColourPixel(old_pixels + (7*FONT_WIDTH), (line * FONT_HEIGHT) + 2 + i, (PColour[Id] >> 8));
			++old_pixels;
		}
	}
}

EFI_STATUS
InitVideo(void)
{
	EFI_STATUS Status;
	EFI_GUID GraphicsOutputProtocolGuid = EFI_GRAPHICS_OUTPUT_PROTOCOL_GUID;
	EFI_GRAPHICS_OUTPUT_PROTOCOL *gop = NULL;
	EFI_GRAPHICS_OUTPUT_MODE_INFORMATION *Info;
	UINT32 ModeNumber, Res;
	UINTN InfoSize;
	UINT32 MaxRes = 0;
	UINT32 BestMode = 0;

	// Locate the GOP.
	Status = uefi_call_wrapper(BS->LocateProtocol, 3, &GraphicsOutputProtocolGuid, NULL, (void **)&gop);
	if (EFI_ERROR(Status)) {
		Print(L"InitVideo: Failed to locate GOP: %r\n", Status);
		gop = NULL;
		return Status;
	}

	// Find the best video mode.
	for (ModeNumber = 0; ModeNumber < gop->Mode->MaxMode; ModeNumber++) {
		Status = uefi_call_wrapper(gop->QueryMode, 4, gop, ModeNumber, &InfoSize, &Info);
		if (!EFI_ERROR(Status)) {
			Res = Info->HorizontalResolution * Info->VerticalResolution;
			if (Res > MaxRes) {
				MaxRes = Res;
				BestMode = ModeNumber;
			}
		}
	}

	// Reset console output.
	Status = uefi_call_wrapper(ST->ConOut->Reset, 2, ST->ConOut, TRUE);
	if (EFI_ERROR(Status)) {
		Print(L"Failed to reset console: %r\n", Status);
		return Status;
	}

	// Set the video mode.
	Status = uefi_call_wrapper(gop->SetMode, 2, gop, BestMode);
	if (EFI_ERROR(Status)) {
		Print(L"Failed to set video mode: %r\n", Status);
		return Status;
	}

	// Enable the UEFI blinking text cursor.
	Status = uefi_call_wrapper(ST->ConOut->EnableCursor, 2, ST->ConOut, TRUE);
	if (EFI_ERROR(Status)) {
		Print(L"Failed to enable the cursor: %r\n", Status);
		return Status;
	}

	// Set text color attributes.
	Status = uefi_call_wrapper(ST->ConOut->SetAttribute, 2, ST->ConOut, EFI_TEXT_ATTR(EFI_LIGHTGRAY, EFI_BLACK));
	if (EFI_ERROR(Status)) {
		Print(L"Failed to set text color attributes: %r\n", Status);
		return Status;
	}

	// Clear the screen.
	Status = uefi_call_wrapper(ST->ConOut->ClearScreen, 1, ST->ConOut);
	if (EFI_ERROR(Status)) {
		Print(L"Failed to clear screen: %r\n", Status);
		return Status;
	}

#if defined(DEBUG_BLD)
	UINTN cols = Info->HorizontalResolution / 8;
	UINTN rows = Info->VerticalResolution / 16;

	Print(L"GOP initialized: %ux%u, %u pixels/scanline\n", gop->Mode->Info->HorizontalResolution,
		gop->Mode->Info->VerticalResolution, gop->Mode->Info->PixelsPerScanLine);
	Print(L"Framebuffer base: 0x%lx, size: %lu bytes\n", gop->Mode->FrameBufferBase,
		gop->Mode->FrameBufferSize);
	Print(L"Text mode: %ux%u\n", cols, rows);
#endif

	Screen = (UINT8 *)gop->Mode->FrameBufferBase;

	Screenwidth = gop->Mode->Info->HorizontalResolution;
	Screenheight = gop->Mode->Info->VerticalResolution;
	PixelsPerScanLine = gop->Mode->Info->PixelsPerScanLine;

	VideoInitFlag = TRUE;

	ClearScreen();

	return EFI_SUCCESS;
}
